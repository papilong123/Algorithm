void delete(LinkList &L Element x)
\\此函数将链表L中的元素x从链表中除去
{
    LNode *p=L->next ,*pre=L, *q;
    while(p){
    if(p=>data = x){
    q=p;
    p=p->next;
    pre->next=p;
    free(q);
}
    else{
    pre=p;
    p=p->next;
    }//else
    }//while
}

void f(LinkList L){
//反向输出链表的值
    if(L->next){
    f(L->next);
}
}

void f(LinkList &L){
//L是带头节点的单链表，删除链表中最小值结点
    LNode *pre=L,*p=pre->next, q;
    LNode *minpre, *minp;
    while(p!=NULL){
         if(p->data<pre->data){
             minp=p;
             minpre=pre;
             }
         pre=p;
         p=p->next;
    }
    minpre->next=minp->next;
    free(minp);
    }  //while
}

void f(Linklist L){
//将带头节点的单链表就地逆置
    LNode *p, *r;
    p=L->next;
    L->next=NULL;
    while(p!=NULL){
        r=p->next;
        p->next=L->next;
        L->next=p;
        p=r;
    }
}

Linklist f(Linklist L){
//使带头结点的L递增有序
    LNode *p, *pre, *r;
    p=L->next->next, p=r;
    L->next->next=NULL;
    while(p!=NULL){
        r=p->next;
        pre=L;
        while(pre->next!=NULL&&pre->data < p->data){
            p->next=pre->next;
            pre->next=p;
        }
        p=r;
    }
return L;
}

void f(Linklist &L,Elemtype a,Elemtype b){
//删除带头节点单链表中a<x<b的元素
    LNode *p, *pre;
    p=L->next,pre=L;
    while(p!=NULL){
        if(p->data>a && p->data<b){
            pre->next=p->next;
            free(p);
            p=pre->next;
        }
        else{
        pre=p;
        p=pre->next;
    }//while
}

void f(Linklist L1, Linklist L2){
//找到两个链表的公共节点
    LNode *La, *Lb, *p1, *p2;
    int dist;
    length(L1)>length(L2)?La=L1: Lb=L2;
    *p1=p1->next, *p2=p2->next;
    dist=length(L1)-length(L2);
    while(dist--)
        p1=p1->next;
    while(p1!=NULL){
        if(p1=p2)
        return p1;
        p1=p1->next;
        p2=p2->next;
    }  //while
    return NULL;
}
        
void f(Linklist L){
//按递增顺序输出单链表的值
    LNode *pre, *p;
    while(L->next!=NULL){
        pre=L, p=p->next;
    while(p->next!=NULL && p->next->data > p->data)
        pre=p, p=p->next;
        






































